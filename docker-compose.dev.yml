services:
  gc-api: # Main service definition named "gc-api"
    container_name: gc-api # Docker container name for this service
    build:
      context: . # Build context is the current directory
      dockerfile: Dockerfile.dev # Uses Dockerfile.dev to build the image
    ports:
      - "${API_PORT}:3000" # Maps the port defined in the API_PORT env variable to container port 3000
    env_file:
      - .env # Loads environment variables from the .env file
    environment:
      - NODE_ENV=development # Sets NODE_ENV to "development"
      - DEBUG=app:*,config:*,migration:*, service:*, error:*, test:* # Sets DEBUG env variable to enable debugging
    volumes:
      - .:/usr/src/app # Mounts local ./src folder to /usr/src/app in the container (source sync)
      - ./uploads:/usr/src/app/uploads # Mounts local ./uploads to /usr/src/app/uploads in the container (for uploaded files)
      - /usr/src/app/node_modules
    restart: unless-stopped
    # Service dependencies
    depends_on:
      gc-db:
        condition: service_healthy
      gc-redis:
        condition: service_healthy

  gc-test:
    container_name: gc-test
    build:
      context: .
      dockerfile: Dockerfile.test
    ports:
      - "${API_PORT_TEST}:3000"
    env_file:
      - .env.test
    environment:
      - NODE_ENV=test
      - DEBUG=test:*
    volumes:
      - .:/usr/src/app
      - ./uploads:/usr/src/app/uploads
    restart: no
    depends_on:
      gc-db:
        condition: service_healthy
      gc-redis:
        condition: service_healthy

  # PostgreSQL service definition
  gc-db:
    # Official PostgreSQL Docker image
    image: postgres:16
    # Explicit container name for easier identification
    container_name: gc-db
    # Automatically restart the container unless stopped manually
    restart: unless-stopped
    # Loads environment variables from the .env file
    env_file:
      - ./.env
    # Maps PostgreSQL port defined in .env (default 5432)
    ports:
      - "${POSTGRES_PORT}:5432"
    # Mounts a local volume containing initialization scripts into the container
    volumes:
      # Mounts the named Docker volume 'gc-pg-data' into PostgreSQL for data persistence
      - gc-pg-data:/var/lib/postgresql/data

    # Checks if PostgreSQL is ready to accept connections
    healthcheck:
      # Command executed to check PostgreSQL status
      test:
        ["CMD", "pg_isready", "-U", "${POSTGRES_USER}", "-d", "${POSTGRES_DB}"]
      # Interval between checks
      interval: 10s
      # Max time for each check
      timeout: 5s
      # Number of attempts before considering the service unhealthy
      retries: 5

  gc-redis:
    # Official Redis Docker image
    image: redis:latest
    # Explicit container name for easier identification
    container_name: gc-redis
    # Automatically restart the container unless stopped manually
    restart: unless-stopped
    # Maps Redis port defined in .env (default 6379)
    ports:
      - "${REDIS_PORT}:6379"
    # Mounts a local volume containing initialization scripts into the container
    volumes:
      - gc-redis-data:/data
    # Checks if Redis is ready to accept connections
    healthcheck:
      # Command executed to check Redis status
      # https://stackoverflow.com/questions/67904609/how-do-you-perform-a-healthcheck-in-the-redis-docker-image
      test: ["CMD", "redis-cli", "ping"]
      # Interval between checks
      interval: 10s
      # Max time for each check
      timeout: 5s
      # Number of attempts before considering the service unhealthy
      retries: 5

# Named volumes declaration
volumes:
  gc-pg-data:
  gc-redis-data:
